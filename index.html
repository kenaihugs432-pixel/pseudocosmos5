<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AR — anchors + local-floor (fix definitivo)</title>
  <style>
    body{margin:0;overflow:hidden;font-family:sans-serif;background:#000;color:#fff}
    #message{position:fixed;left:10px;top:10px;z-index:20;background:#fff;color:#000;padding:8px;border-radius:6px;box-shadow:0 2px 10px rgba(0,0,0,.2);max-width:calc(100% - 24px)}
    #errorBox{position:fixed;left:10px;bottom:10px;right:10px;z-index:21;background:rgba(0,0,0,0.8);color:#fff;padding:10px;border-radius:6px;display:none;max-height:40vh;overflow:auto;font-family:monospace;font-size:13px}
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js",
      "three/": "https://cdn.jsdelivr.net/npm/three@0.154.0/"
    }
  }
  </script>

  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
</head>
<body>
  <div id="message">Iniciando…</div>
  <div id="errorBox"></div>

  <script type="module">
  (async () => {
    const showError = txt => {
      const box = document.getElementById('errorBox');
      box.style.display = 'block';
      box.textContent += txt + "\n\n";
      console.error(txt);
    };
    const setMessage = m => document.getElementById('message').textContent = m;

    // quick HEAD check do GLB
    try {
      const head = await fetch('aha2.glb', { method: 'HEAD' });
      if (!head.ok) { showError('aha2.glb não encontrado (HTTP ' + head.status + ')'); setMessage('aha2.glb não encontrado. Abra fallback.'); return; }
    } catch (e) { showError('Erro checando aha2.glb: ' + e); return; }

    // importar libs
    let THREE, GLTFLoaderModule, ARButtonModule, SkeletonUtilsModule;
    try {
      THREE = await import('three');
      GLTFLoaderModule = await import('https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/loaders/GLTFLoader.js');
      ARButtonModule = await import('https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/webxr/ARButton.js');
      SkeletonUtilsModule = await import('https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/utils/SkeletonUtils.js');
    } catch (err) {
      showError('Falha ao carregar libs via CDN/importmap: ' + err);
      setMessage('Erro carregando libs. Abra fallback.');
      return;
    }
    const { GLTFLoader } = GLTFLoaderModule;
    const { ARButton } = ARButtonModule;
    let SkeletonUtils = SkeletonUtilsModule.SkeletonUtils || SkeletonUtilsModule.default || SkeletonUtilsModule;
    if (!SkeletonUtils || (typeof SkeletonUtils.clone !== 'function')) { SkeletonUtils = null; }

    // renderer (forçamos local-floor como reference space type)
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    try { renderer.xr.setReferenceSpaceType && renderer.xr.setReferenceSpaceType('local-floor'); }
    catch (e) { console.warn('setReferenceSpaceType não suportado:', e); }
    if ('outputColorSpace' in renderer && THREE.SRGBColorSpace) renderer.outputColorSpace = THREE.SRGBColorSpace;
    else if ('outputEncoding' in renderer) renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.4;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

    // luzes
    scene.add(new THREE.AmbientLight(0xffffff, 1.0));
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.7); dir.position.set(1,2,1); scene.add(dir);

    // reticle - decomposição para position/quaternion
    const ring = new THREE.RingGeometry(0.07, 0.09, 32).rotateX(-Math.PI/2);
    const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
    const reticle = new THREE.Mesh(ring, ringMat);
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    reticle.position.set(0,0,0);
    reticle.quaternion.set(0,0,0,1);
    reticle.scale.set(1,1,1);
    scene.add(reticle);

    // env (opcional)
    const pmrem = new THREE.PMREMGenerator(renderer); pmrem.compileEquirectangularShader();
    try {
      const tl = new THREE.TextureLoader();
      const envUrl = 'https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg';
      const envTex = await new Promise((res, rej) => tl.load(envUrl, res, undefined, rej));
      envTex.mapping = THREE.EquirectangularReflectionMapping;
      if ('colorSpace' in envTex) envTex.colorSpace = (THREE.SRGBColorSpace ? THREE.SRGBColorSpace : envTex.colorSpace);
      else if ('encoding' in envTex) envTex.encoding = THREE.sRGBEncoding;
      const envMap = pmrem.fromEquirectangular(envTex).texture;
      scene.environment = envMap;
      envTex.dispose(); pmrem.dispose();
    } catch(e) { console.warn('Env falhou (não crítico):', e); }

    // loader
    const loader = new GLTFLoader();
    let baseGLTF = null;
    let modelPrototype = null;
    let modelReady = false;
    let placedModel = null;

    // anchors + lockedMatrix
    let sessionAnchorsSupported = false;
    let sessionLocalRefSpace = null;
    let lastHit = null; // último XRHitTestResult válido
    let lockedWorldMatrix = null; // fallback matrixWorld

    loader.load('aha2.glb', (gltf) => {
      baseGLTF = gltf;
      modelPrototype = gltf.scene;
      modelPrototype.scale.set(0.5,0.5,0.5);
      modelPrototype.traverse(n => {
        if (n.isMesh && n.material) {
          n.material.side = THREE.DoubleSide;
          if (n.material.metalness !== undefined && n.material.metalness > 0.9) n.material.metalness = 0.6;
          if (n.material.roughness !== undefined && n.material.roughness < 0.1) n.material.roughness = 0.5;
          ['map','normalMap','metalnessMap','roughnessMap','emissiveMap'].forEach(k => {
            if (n.material[k]) {
              const t = n.material[k];
              if ('colorSpace' in t) t.colorSpace = (THREE.SRGBColorSpace ? THREE.SRGBColorSpace : t.colorSpace);
              else if ('encoding' in t) t.encoding = THREE.sRGBEncoding;
            }
          });
          n.material.needsUpdate = true;
        }
      });
      modelReady = true;
      setMessage('Modelo carregado — aponte para o anel verde e toque para posicionar.');
    }, undefined, (err) => showError('Erro carregando aha2.glb: ' + err));

    // AR button / Quick Look fallback
    const usdzUrl = new URL('aha2.usdz', location.href).href;
    function isIOS() {
      return /iP(hone|od|ad)/.test(navigator.platform)
        || (navigator.userAgent.includes("Mac") && "ontouchend" in document);
    }
    if (isIOS()) {
      const arLink = document.createElement('a');
      arLink.href = usdzUrl; arLink.setAttribute('rel','ar');
      arLink.style.position='fixed'; arLink.style.left='10px'; arLink.style.bottom='10px'; arLink.style.zIndex='40';
      arLink.style.padding='10px 14px'; arLink.style.background='#0b84ff'; arLink.style.color='#fff'; arLink.style.borderRadius='8px';
      arLink.textContent='Abrir AR (iOS Quick Look)'; document.body.appendChild(arLink);
      const mv = document.createElement('model-viewer');
      mv.setAttribute('src','aha2.glb'); mv.setAttribute('ios-src', usdzUrl); mv.setAttribute('ar','');
      mv.setAttribute('ar-modes','webxr quick-look scene-viewer');
      mv.setAttribute('style','position:fixed;right:10px;bottom:10px;width:120px;height:120px;z-index:39;border-radius:8px;overflow:hidden;');
      mv.setAttribute('camera-controls',''); document.body.appendChild(mv);
      setMessage('iOS detectado — toque "Abrir AR (iOS Quick Look)".');
    } else {
      try {
        document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));
      } catch(e) { showError('Erro criando botão AR: ' + e); }
    }

    // controller
    const controller = renderer.xr.getController(0);
    scene.add(controller);

    // quando sessão iniciar
    renderer.xr.addEventListener('sessionstart', async () => {
      const session = renderer.xr.getSession();
      if (!session) return;
      // veja se anchors estão disponíveis
      sessionAnchorsSupported = !!(session.requestHitTestSource && (typeof XRAnchor !== 'undefined' || 'anchors' in session));
      console.log('anchors supported:', sessionAnchorsSupported);

      // tenta pegar local-floor e guarda
      try {
        session.requestReferenceSpace('local-floor').then(ref => {
          sessionLocalRefSpace = ref;
          console.log('session._localRefSpace configurado (local-floor).');
        }).catch(e => {
          console.warn('Não foi possível obter local-floor (fallback):', e);
          sessionLocalRefSpace = renderer.xr.getReferenceSpace();
        });
      } catch (e) {
        console.warn('Erro pedindo local-floor:', e);
        sessionLocalRefSpace = renderer.xr.getReferenceSpace();
      }

      // opcional: inicializa um container de anchors
      session._anchors = session._anchors || [];
    });

    // hit-test + loop
    const tmpMatrix = new THREE.Matrix4();
    renderer.setAnimationLoop((timestamp, frame) => {
      if (frame) {
        const session = renderer.xr.getSession();
        const referenceSpace = sessionLocalRefSpace || renderer.xr.getReferenceSpace();

        // criar hit test source (viewer) se necessário
        if (session && !session._hitTestSourceRequested) {
          session._hitTestSourceRequested = true;
          session.requestReferenceSpace('viewer').then(viewerSpace => {
            session.requestHitTestSource({ space: viewerSpace }).then(src => {
              session._hitTestSource = src;
              console.log('Hit test source criado.');
            }).catch(e => console.warn('requestHitTestSource failed', e));
          }).catch(e => console.warn('requestReferenceSpace failed', e));
        }

        const ht = session && session._hitTestSource;
        if (ht) {
          const results = frame.getHitTestResults(ht);
          if (results.length > 0) {
            const hit = results[0];
            lastHit = hit; // guardamos o hit atual para usar no select()
            // IMPORTANTE: pedimos pose no referenceSpace 'local-floor' (fixo no mundo)
            const pose = hit.getPose(referenceSpace);
            if (pose) {
              tmpMatrix.fromArray(pose.transform.matrix);
              reticle.matrix.copy(tmpMatrix);
              reticle.matrix.decompose(reticle.position, reticle.quaternion, reticle.scale);
              reticle.visible = true;
              reticle.updateMatrixWorld(true);
            } else {
              reticle.visible = false;
            }
          } else {
            lastHit = null;
            reticle.visible = false;
          }
        }
      }

      // STEP: se o placedModel tiver um anchor, resolvemos sua pose via anchor.anchorSpace
      if (frame && placedModel && placedModel._anchor) {
        try {
          const anchorSpace = placedModel._anchor.anchorSpace;
          const refSpace = sessionLocalRefSpace || renderer.xr.getReferenceSpace();
          const anchorPose = frame.getPose(anchorSpace, refSpace);
          if (anchorPose) {
            const m = new THREE.Matrix4().fromArray(anchorPose.transform.matrix);
            // aplicamos diretamente a matrixWorld do modelo (convertendo para local via parent)
            const parent = placedModel.parent || scene;
            const invParent = new THREE.Matrix4().copy(parent.matrixWorld).invert();
            const local = new THREE.Matrix4().multiplyMatrices(invParent, m);
            placedModel.matrix.copy(local);
            placedModel.matrixAutoUpdate = false;
            placedModel.updateMatrixWorld(true);
          } else {
            // fallback: não conseguimos pose do anchor — não fazer nada
          }
        } catch (e) {
          console.warn('Erro atualizando pose via anchor:', e);
        }
      } else if (placedModel && lockedWorldMatrix) {
        // fallback antigo: forçar lockedWorldMatrix
        const parent = placedModel.parent || scene;
        const parentWorld = new THREE.Matrix4().copy(parent.matrixWorld || new THREE.Matrix4().identity());
        const invParent = new THREE.Matrix4().copy(parentWorld).invert();
        const newLocal = new THREE.Matrix4().multiplyMatrices(invParent, lockedWorldMatrix);
        placedModel.matrix.copy(newLocal);
        placedModel.matrixAutoUpdate = false;
        placedModel.updateMatrixWorld(true);
      }

      renderer.render(scene, camera);
    });

    // SELECT: tenta criar anchor a partir do lastHit; se não suportado, usa fallback lockedWorldMatrix
    controller.addEventListener('select', async () => {
      if (!modelReady) { setMessage('Modelo ainda carregando — aguarde.'); console.warn('Select ignorado: modelo não pronto'); return; }
      if (!reticle.visible) { setMessage('Aponte a câmera até o anel aparecer.'); return; }

      const session = renderer.xr.getSession();

      try {
        if (placedModel) {
          // reposiciona e re-trava (tenta recriar anchor se suportado)
          placedModel.position.copy(reticle.position);
          placedModel.quaternion.copy(reticle.quaternion);
          placedModel.scale.copy(reticle.scale);
          placedModel.updateMatrixWorld(true);

          // tenta criar novo anchor a partir do lastHit (se possível)
          if (lastHit && typeof lastHit.createAnchor === 'function' && sessionAnchorsSupported && session) {
            try {
              const anchor = await lastHit.createAnchor(); // cria anchor at hit
              session._anchors = session._anchors || [];
              session._anchors.push(anchor);
              // guarda anchor no placedModel para usar no loop
              placedModel._anchor = anchor;
              // também grava lockedWorldMatrix como backup
              lockedWorldMatrix = placedModel.matrixWorld.clone();
              placedModel.matrixAutoUpdate = false;
              console.log('anchor criado (reposicionado).', anchor);
              console.log('placedModel.parent:', placedModel.parent && placedModel.parent.type);
              return;
            } catch (e) {
              console.warn('createAnchor falhou (reposicionamento):', e);
              // cairá no fallback abaixo
            }
          }

          // fallback sem anchor
          lockedWorldMatrix = placedModel.matrixWorld.clone();
          placedModel.matrixAutoUpdate = false;
          console.log('Modelo existente reposicionado e travado (fallback).');
          console.log('DEBUG lockedWorldMatrix:', lockedWorldMatrix.elements);
          console.log('placedModel.parent:', placedModel.parent && placedModel.parent.type);
          return;
        }

        // Criar novo clone
        const clone = (SkeletonUtils ? SkeletonUtils.clone(modelPrototype) : modelPrototype.clone(true));
        // sempre adicione à cena (não ao camera/controller)
        scene.add(clone);
        clone.position.copy(reticle.position);
        clone.quaternion.copy(reticle.quaternion);
        clone.scale.copy(reticle.scale);
        clone.updateMatrixWorld(true);

        // agora tente criar anchor (pref)
        let createdAnchor = null;
        if (lastHit && typeof lastHit.createAnchor === 'function' && sessionAnchorsSupported && session) {
          try {
            createdAnchor = await lastHit.createAnchor();
            session._anchors = session._anchors || [];
            session._anchors.push(createdAnchor);
            clone._anchor = createdAnchor;
            // quando anchor existir, vamos confiar na anchor para atualizar pose no loop
            clone.matrixAutoUpdate = false;
            console.log('anchor criado com sucesso:', createdAnchor);
          } catch (e) {
            console.warn('createAnchor falhou na criação inicial:', e);
            createdAnchor = null;
          }
        }

        // se não temos anchor, usamos lockedWorldMatrix fallback
        placedModel = clone;
        if (!createdAnchor) {
          lockedWorldMatrix = placedModel.matrixWorld.clone();
          placedModel.matrixAutoUpdate = false;
          console.log('Clone adicionado e travado (fallback, sem anchor).');
        } else {
          // já travamos matrixAutoUpdate false; lockedWorldMatrix como backup
          lockedWorldMatrix = placedModel.matrixWorld.clone();
          console.log('Clone adicionado e ancorado.');
        }

        console.log('DEBUG placedModel world pos:', new THREE.Vector3().setFromMatrixPosition(placedModel.matrixWorld));
        console.log('DEBUG camera world pos:', new THREE.Vector3().setFromMatrixPosition(camera.matrixWorld));
        console.log('placedModel.parent:', placedModel.parent && placedModel.parent.type);
      } catch (e) {
        showError('Falha ao clonar/colocar modelo: ' + e);
      }
    });

    // helper para remover (via console)
    window.__resetPlacedModel = () => {
      try {
        const session = renderer.xr.getSession();
        if (session && session._anchors) {
          session._anchors.forEach(a => { try { a.delete && a.delete(); } catch(e){} });
          session._anchors = [];
        }
      } catch(e){}
      if (placedModel) {
        try { scene.remove(placedModel); } catch(e){}
      }
      placedModel = null; lockedWorldMatrix = null;
      setMessage('Modelo removido.');
      console.log('placedModel resetado');
    };

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

  })();
  </script>
</body>
</html>
